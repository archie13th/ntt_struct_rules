// Code generated from opcode.tmpl.go and by 'go generate'; DO NOT EDIT.
// This file was generated by robots at 2024-06-08 16:48:52.968602692 +0200 CEST m=+1.028058892

// Package opcode defines the opcodes used in T3XF.
package opcode

const (
	REF        Opcode = 0
	GOTO       Opcode = 1
	LINE       Opcode = 2
	OPERATION  Opcode = 3
	FROZEN_REF Opcode = 4

	// Request the action described in str from the user.
	ACTION Opcode = 0x1003

	// Activate an altstep and return a default object. Block blk
	// shall contain an altstep call, including any required
	// parameters.
	ACTIVATE Opcode = 0x0d03

	// Evaluate a + b, pushing the result.
	ADD Opcode = 0x0413

	// When a module defines a type named ‘address’ then this
	// definition is returned from the address operation.
	//
	// When a module fails to define an address type then this
	// operation returns a built-in opaque address type object.
	//
	// Each defined module has its own unique definition of address.
	ADDRESS Opcode = 0x0ea3

	// Test the state of component comp for the alive condition. Push
	// the boolean result onto the stack.
	ALIVE Opcode = 0x1103

	// Test the state of all parallel test components for any that
	// are alive. Push the boolean result onto the stack.
	ALIVE1 Opcode = 0x1113

	// Test the state of all parallel test components checking that
	// all are alive. Push the boolean result onto the stack.
	ALIVEA Opcode = 0x1123

	ALLFROM Opcode = 0x06a3

	ALLFROMP Opcode = 0x06b3

	// Evaluate the contents of blk until one of the contained
	// alternatives succeeds.
	//
	// An empty block is allowed: activated defaults will still be
	// included in the operation.
	//
	// If the successful alternative executes a repeat statement then
	// the whole block execution will be re-evaluated.
	ALT Opcode = 0x0383

	// Same as `alt` with disabled defaults (`@nodefault`)
	ALTND Opcode = 0x2023

	// Define an altstep object from a block pblk containing its
	// parameters, bblk containing its behaviour and a name, and then
	// attach it to the module object owning the current block.
	ALTSTEP Opcode = 0x0803

	// Define a bound altstep object from a component type comp, a
	// block pblk containing its parameters, bblk containing its
	// behaviour and a name, then attach it to the module object
	// owning the current block.
	ALTSTEPB Opcode = 0x0813

	// Define a bound altstep object from a component type comp, a
	// block pblk containing its parameters, bblk containing its
	// behaviour and a name, attach the attributes from block ablk,
	// and then attach it to the module object owning the current
	// block.
	ALTSTEPBW Opcode = 0x0833

	// Define an altstep object from a block pblk containing its
	// parameters, bblk containing its behaviour and a name, attach
	// the attributes from block ablk, and then attach it to the
	// module object owning the current block.
	ALTSTEPW Opcode = 0x0823

	// With a boolean first argument, perform the logical and
	// operation and return the boolean result. The second argument
	// may be either another boolean or a block. If the first
	// argument is false then the second argument shall not be
	// evaluated.
	//
	// With bitstring, hexstring or octetstring inputs, perform the
	// bitwise and operation and return the result. The result type
	// will be of the same base type as the inputs.
	AND Opcode = 0x0483

	// Push a special any-value literal on the stack, corresponding
	// to the TTCN-3 ‘?’ literal.
	ANY Opcode = 0x0603

	// Push a special any-value-or-none literal on the stack,
	// corresponding to the TTCN-3 ‘*’ literal.
	ANYN Opcode = 0x0613

	APPLY Opcode = 0x0193

	// Create an array type object from an element type type and a
	// dimension dim. Push the resulting type object on the stack.
	// The array dimension shall be either a positive integer or a
	// range of integers (positive, no infinities.)
	ARRAY Opcode = 0x0ee3

	// Assign the value of b to a.
	//
	// The types of a and b must be compatible.
	ASSIGN Opcode = 0x0583

	// Assign the value of b to a. Leave object a on the stack.
	//
	// The types of a and b must be compatible.
	ASSIGND Opcode = 0x0593

	AT_DEFAULT Opcode = 0x2013

	// Convert bitstring bit into a hexstring and push it onto the
	// stack.
	BIT2HEX Opcode = 0x18c3

	// Convert bitstring bit into an integer and push it onto the
	// stack.
	BIT2INT Opcode = 0x18b3

	// Convert bitstring bit into an octetstring and push it onto the
	// stack.
	BIT2OCT Opcode = 0x18d3

	// Convert bitstring bit into a charstring and push it onto the
	// stack.
	BIT2STR Opcode = 0x18e3

	// Push a bitstring literal onto the stack. This is a
	// variable-length instruction with the details of the literal
	// bitstring following the instruction itself: first, a length
	// field, and then the bytes of the bitstring.
	//
	// The length field is encoded with the same byte order as has
	// been selected for instructions. The length contains the number
	// of bits.
	//
	// The string itself is always encoded with the first bit of the
	// string at the lowest file offset – the natural ordering for
	// strings – and in the most-significant bit of that byte.
	//
	// Padding shall be placed at the end of the string bytes to
	// restore the correct alignment for following instructions.
	BITS Opcode = 0x0113

	// Push the built-in bitstring type object.
	BITSTRING Opcode = 0x0e03

	// Switch from scanning back to execution mode pushing a block
	// object onto the stack.
	BLOCK Opcode = 0x0083

	// Push the built-in boolean type object.
	BOOLEAN Opcode = 0x0e13

	// Leave the enclosing loop construct.
	BREAK Opcode = 0x03c3

	// Concatenates strings a and b and returns the result. Objects a
	// and b must both be strings of the same base type.
	CAT Opcode = 0x0563

	// Convert single character string char into an integer and push
	// it onto the stack.
	CHAR2INT Opcode = 0x1883

	// Convert charstring char into an octetstring and push it onto
	// the stack.
	CHAR2OCT Opcode = 0x1893

	// Push the built-in charstring type object.
	CHARSTRING Opcode = 0x0e23

	// Push the built-in universal charstring type object.
	CHARSTRINGU Opcode = 0x0e33

	// Create a pure check condition on port port. Block mblk shall
	// contain code to perform the matching of input. When the
	// condition is true (matched) then the enclosing alt will
	// execute block ablk to perform variable assignments.
	CHECK Opcode = 0x14a3

	// Any port check
	CHECK1 Opcode = 0x14b3

	CHECKSTATE Opcode = 0x1783

	// All port checkstate
	CHECKSTATEAL Opcode = 0x1793

	// Any port checkstate
	CHECKSTATEAN Opcode = 0x17a3

	// Clear all contents from the input queue of port p.
	CLEAR Opcode = 0x1383

	// Clear all contents from the input queues of all ports on the
	// current component.
	CLEARA Opcode = 0x1393

	// Clone obj and push back clone.
	CLONE Opcode = 0x0403

	// Wrap obj as closure
	CLOSURE Opcode = 0x11f3

	CLOSURETYPE Opcode = 0x0e93

	// Build a collection from a marked listed of objects,
	// potentially empty. The objects and the mark are removed from
	// the stack and replaced with a collection object.
	COLLECT Opcode = 0x0093

	// Make a complement template literal from the input value list
	// vlist. Push the resulting object on the stack.
	COMPLEMENT Opcode = 0x0623

	// Construct a component type object with initialisation from
	// block iblk and push on to the stack.
	COMPONENT Opcode = 0x0f23

	// Construct a component type object with initialisation from
	// block iblk, extending components listed in collection coll and
	// push on to the stack.
	COMPONENTX Opcode = 0x0f33

	// Connect ports p1 and p2.
	CONNECT Opcode = 0x1083

	// Create a constant data definition from a block vblk containing
	// the statements of its value, a type type and a name.
	CONST Opcode = 0x0843

	// Create a constant data definition from a block vblk containing
	// the statements of its value, a type type and a name, applying
	// attributes from block ablk.
	CONSTW Opcode = 0x0853

	// Repeat the enclosing loop construct.
	CONTINUE Opcode = 0x03d3

	// Create a control part definition from a block blk containing
	// the statements of its behaviour.
	CONTROL Opcode = 0x0863

	// Create an instance of a component of type ctype and push the
	// result onto the stack.
	CREATE Opcode = 0x1183

	// Create an alive-type instance of a component of type ctype and
	// push the result onto the stack.
	CREATEA Opcode = 0x1193

	// Create a named alive-type instance of a component of type
	// ctype and push the result onto the stack. The component
	// instance name is taken from the name parameter.
	CREATEAN Opcode = 0x11b3

	// Create a named instance of a component of type ctype and push
	// the result onto the stack. The component instance name is
	// taken from the name parameter.
	CREATEN Opcode = 0x11a3

	// Deactivate default altstep default.
	DEACTIVATE Opcode = 0x0d23

	// Deactivate all altsteps activated on the current component.
	DEACTIVATEA Opcode = 0x0d33

	// The encoded value enc is decoded and the decoded content
	// will be matched against the provided decTemplate returning
	// a boolean value res on the stack
	DECMATCH Opcode = 0x1ff3

	// Decode encoded bitstring enc placing the result in dec and
	// returning integer res holding the outcome of the operation: 0
	// indicates success, 1 indicates unspecified failure and 2
	// indicates insufficient data (retry after adding bits to enc.)
	DECVALUE Opcode = 0x1a83

	DEF Opcode = 0x05b3

	// Push the built-in default type object.
	DEFAULT Opcode = 0x0ec3

	// Break the connection between port p1 and port p2.
	DISCONNECT Opcode = 0x1093

	// Break all connections from component comp.
	DISCONNECTA Opcode = 0x10a3

	// Break all connections on all components.
	DISCONNECTAA Opcode = 0x10b3

	// Evaluate a / b, pushing the result on the stack.
	//
	// The types of a and b must be compatible. The returned object
	// has the base type of the input parameters and is constant.
	DIV Opcode = 0x0453

	// Test the state of component comp for the done condition,
	// contributing this to an enclosing alt or interleave statement.
	DONE Opcode = 0x1143

	// Test the state of all parallel test components for any that
	// are done, contributing this to an enclosing alt or interleave
	// statement.
	DONE1 Opcode = 0x1153

	// Test the state of all parallel test components checking that
	// all are done, contributing this to an enclosing alt or
	// interleave statement.
	DONEA Opcode = 0x1163

	// Implements the TTCN-3 do/while statement using two block
	// arguments.
	//
	// Block body is executed and then loop condition block cond is
	// evaluated. If the condition returns true then the process is
	// repeated.
	//
	// Execution terminates when the loop condition returns a false
	// value.
	DOWHILE Opcode = 0x0363

	// Remove the item at the top of the stack and discard it.
	DROP Opcode = 0x00a3

	// Create an alternative for an enclosing alt operation that is
	// immediately successful. Block blk contains the code to execute
	// if this alternative is chosen by the containing alt.
	ELSE Opcode = 0x03a3

	// Attach the encode attribute val to the object owning the
	// current block.
	ENCODE Opcode = 0x0c43

	// Attach the overriding encode attribute val to the object
	// owning the current block.
	ENCODEO Opcode = 0x0c63

	// Encode value value returning bitstring res holding the encoded
	// result.
	ENCVALUE Opcode = 0x1a73

	// Convert enumerated enum into an integer and push it onto the
	// stack.
	ENUM2INT Opcode = 0x1a53

	// Build an enumerated object from the terms described in block
	// blk. Push the resulting object onto the stack.
	ENUMERATED Opcode = 0x0f03

	// Evaluate a == b, pushing the boolean result.
	EQ Opcode = 0x0503

	// Push a special literal on the stack corresponding to the error
	// term of verdicttype.
	ERROR Opcode = 0x02e3

	// Execute block blk. This is an optimisation of if(true), giving
	// a space saving of two operations with considerably better
	// performance.
	//
	// The motivation for this operation is the translation of a
	// select statement containing only a single else statement.
	// Placing the block inline is not possible because of the issue
	// of variable scoping.
	EXEC Opcode = 0x0373

	// Execute testcase and return its verdict. The input parameter
	// is a block blk containing any actual parameters to the
	// testcase, followed by the invocation of the testcase itself.
	EXECUTE Opcode = 0x1063

	// Same as execute, but with logging disabled.
	EXECUTED Opcode = 0x11d3

	// Execute testcase and return its verdict. The input parameter
	// is a block blk containing any actual parameters to be supplied
	// to the testcase, followed by the invocation of the testcase
	// itself. Time limit limit shall be applied to the testcase
	// execution.
	EXECUTEL Opcode = 0x1073

	// Same as executel, but with logging disabled.
	EXECUTELD Opcode = 0x11c3

	// Attach the extension attribute val to the object owning the
	// current block.
	EXTENSION Opcode = 0x0c83

	// Attach the overriding extension attribute val to the object
	// owning the current block.
	EXTENSIONO Opcode = 0x0ca3

	// Push a special literal on the stack corresponding to the fail
	// term of verdicttype.
	FAIL Opcode = 0x02d3

	// Push a special false literal onto the stack.
	FALSE Opcode = 0x0283

	// Build a field description from type and name and attach it to
	// the structured type object owning the current block.
	FIELD Opcode = 0x0723

	// Build an optional field description from type and name and
	// attach it to the structured type object owning the current
	// block.
	FIELDO Opcode = 0x0733

	// Push the built-in float type object.
	FLOAT Opcode = 0x0e43

	// Convert float flt into an integer and push it onto the stack.
	FLOAT2INT Opcode = 0x1873

	// Implements the TTCN-3 for statement using four block
	// arguments.
	//
	// First, block init is executed to establish initial values.
	//
	// Block cond is evaluated to test the loop condition. If the
	// block yields a true value then block body is executed followed
	// by block incr to change the loop condition before looping to
	// evaluate the loop condition again.
	//
	// Execution terminates when the loop condition returns a false
	// value.
	//
	// Variables created within block init are visible within blocks
	// cond, incr and body. Such variables will be destroyed when the
	// operation terminates.
	FOR Opcode = 0x0343

	// Implements the TTCN-3 .from operation applied to mapv of
	// type: `type map from A to B MapT`. A setofFromType is provided
	// for creation of the return value.
	// Return value is of type `set of A` containing all keys
	// from the map.
	FROM Opcode = 0x06c3

	// Push a float literal onto the stack, with the value coded as
	// an ASCII string to allow for (nearly) arbitrary size and
	// precision. This is a variable-length instruction with the
	// details of the literal string following the instruction
	// itself: first, a length field, and then the bytes of the
	// string.
	//
	// The length field is encoded with the same byte order as has
	// been selected for instructions. The string itself is always
	// encoded with the first byte of the string at the lowest file
	// offset – the natural ordering for strings.
	//
	// Padding shall be placed at the end of the string bytes to
	// restore the correct alignment for following instructions.
	FSTR Opcode = 0x0173

	// Define a function object from a block pblk containing its
	// parameters, bblk containing its behaviour and a name, and then
	// attach it to the module object owning the current block.
	FUNCTION Opcode = 0x0903

	// Define a bound function object from a component type comp, a
	// block pblk containing its parameters, bblk containing its
	// behaviour and a name, then attach it to the module object
	// owning the current block.
	FUNCTIONB Opcode = 0x0913

	// Define a value-returning function object from return type, a
	// block pblk containing its parameters, bblk containing its
	// behaviour and a name, and then attach it to the module object
	// owning the current block.
	FUNCTIONV Opcode = 0x0943

	// Define a value-returning bound function object from return
	// type, a component type comp, a block pblk containing its
	// parameters, bblk containing its behaviour and a name, then
	// attach it to the module object owning the current block.
	FUNCTIONVB Opcode = 0x0953

	// Define an external function object from a block pblk
	// containing its parameters and a name, and then attach it to
	// the module object owning the current block.
	FUNCTIONX Opcode = 0x0983

	// Define a value-returning external function object from return
	// type, a block pblk containing its parameters and a name, and
	// then attach it to the module object owning the current block.
	FUNCTIONXV Opcode = 0x09a3

	// Define a value-returning external function object from return
	// type, a block pblk containing its parameters and a name,
	// attach the attributes from block ablk, and then attach it to
	// the module object owning the current block.
	FUNCTIONXVW Opcode = 0x09b3

	// Define an external function object from a block pblk
	// containing its parameters and a name, attach the attributes
	// from block ablk, and then attach it to the module object
	// owning the current block.
	FUNCTIONXW Opcode = 0x0993

	// Evaluate a >= b, pushing the boolean result.
	GE Opcode = 0x0513

	// When object obj is of type record, record-of, set, set-of,
	// union, array or string, fetch a reference to the element
	// indexed by idx, where idx is an unsigned integer value.
	//
	// When object obj is of type component fetch a reference to the
	// field name.
	GET Opcode = 0x0573

	// Get the local verdict of the current component and push it on
	// the stack. Use within the control part is a runtime error.
	GETVERDICT Opcode = 0x1043

	// Evaluate a > b, pushing the boolean result.
	GT Opcode = 0x0523

	// Instruct port p to accept no further input.
	HALT Opcode = 0x13a3

	// Instruct all ports on the current component to accept no
	// further input.
	HALTA Opcode = 0x13b3

	// Convert hexstring hex into a bitstring and push it onto the
	// stack.
	HEX2BIT Opcode = 0x1903

	// Convert hexstring hex into an integer and push it onto the
	// stack.
	HEX2INT Opcode = 0x18f3

	// Convert hexstring hex into an octetstring and push it onto the
	// stack.
	HEX2OCT Opcode = 0x1913

	// Convert hexstring hex into a charstring and push it onto the
	// stack.
	HEX2STR Opcode = 0x1923

	// Push the built-in hexstring type object.
	HEXSTRING Opcode = 0x0e53

	// Same behaviour as 'def'.
	IDEF Opcode = 0x05c3

	// Push a float literal onto the stack. The encoding of the
	// floating-point value follows the instruction word and shall be
	// in IEEE754 double-precision format.
	//
	// IEEE754 double precision has a fixed size of 64-bits. Padding
	// will be required if the current instruction width is greater
	// than 64-bit.
	//
	// The eight bytes of the representation must be swapped if
	// swapping is enabled.
	IEEE754DP Opcode = 0x0153

	// Execute block blk if cond is true.
	IF Opcode = 0x0303

	// Execute block tblk if cond is true else execute block fblk.
	IFELSE Opcode = 0x0313

	IFIELD Opcode = 0x05d3

	// Modify obj to allow it to match optional fields in record or
	// set objects. Leave the object on the stack.
	IFPRESENT Opcode = 0x0633

	// When object obj is of type record, record-of, set, set-of,
	// union, array or string, fetch a reference to the element
	// indexed by x, where x is an unsigned integer value in the
	// range 0 to 32767.
	//
	// This is the performance-optimised version of the get operation
	// above.
	IGET Opcode = 0x05a3

	// Bind a type and name into an input value parameter object and
	// then attach this to the owning function (altstep, testcase)
	// object.
	IN Opcode = 0x0743

	// Push a special literal on the stack corresponding to the
	// inconc term of verdicttype.
	INCONC Opcode = 0x02c3

	// Push a special -infinity literal onto the stack.
	INFINITYN Opcode = 0x0263

	// Push a special +infinity literal onto the stack.
	INFINITYP Opcode = 0x0273

	// Bind a type and name into an input/output value parameter
	// object and then attach this to the owning function (altstep,
	// testcase) object.
	INOUT Opcode = 0x0753

	// Convert integer int into a bitstring and push it onto the
	// stack. len supplies a minimum length for the resulting string.
	INT2BIT Opcode = 0x1823

	// Convert integer int into a single character string and push it
	// onto the stack.
	INT2CHAR Opcode = 0x1803

	INT2ENUM Opcode = 0x1aa3

	// Convert integer int into a float and push it onto the stack.
	INT2FLOAT Opcode = 0x1863

	// Convert integer int into a hexstring and push it onto the
	// stack. len supplies a minimum length for the resulting string.
	INT2HEX Opcode = 0x1833

	// Convert integer int into an octetstring and push it onto the
	// stack. len supplies a minimum length for the resulting string.
	INT2OCT Opcode = 0x1843

	// Convert integer int into a charstring and push it onto the
	// stack.
	INT2STR Opcode = 0x1853

	// Push the built-in integer type object.
	INTEGER Opcode = 0x0e63

	// Evaluate the contents of blk until all of the contained
	// alternatives succeed.
	//
	// An empty block is allowed: activated defaults will still be
	// included in the operation.
	//
	// Actions attached to successful alternatives may extend the set
	// of alternatives to complete.
	INTERLEAVE Opcode = 0x0393

	// Stack operations might be dynamic.
	ISBOUND Opcode = 0x1ad3

	// Tests the object obj to determine if it is the selected field
	// of a union and pushes the boolean result. obj must reference a
	// field of a union.
	ISCHOSEN Opcode = 0x19f3

	// Tests the presence of object obj and pushes the boolean
	// result. obj must reference an optional field of a record or
	// set.
	ISPRESENT Opcode = 0x19e3

	// Push an integer literal onto the stack, with the integer coded
	// as an ASCII string to allow for (nearly) arbitrary size. This
	// is a variable-length instruction with the details of the
	// literal string following the instruction itself: first, a
	// length field, and then the bytes of the string.
	//
	// The length field is encoded with the same byte order as has
	// been selected for instructions. The string itself is always
	// encoded with the first byte of the string at the lowest file
	// offset – the natural ordering for strings.
	//
	// Padding shall be placed at the end of the string bytes to
	// restore the correct alignment for following instructions.
	ISTR Opcode = 0x0163

	// Tests the object obj to determine is it is concrete value
	// (defined, not a template) and pushes the boolean result.
	ISVALUE Opcode = 0x1a63

	// Stop behaviour on component comp and move it to the killed
	// state.
	KILL Opcode = 0x13c3

	// Stop behaviour on all parallel test components, moving them to
	// the killed state.
	KILLA Opcode = 0x13d3

	// Test the state of component comp for the killed condition,
	// contributing this to an enclosing alt or interleave statement.
	KILLED Opcode = 0x1243

	// Test the state of all parallel test components for any that
	// are killed, contributing this to an enclosing alt or
	// interleave statement.
	KILLED1 Opcode = 0x1253

	// Test the state of all parallel test components checking that
	// all are killed, contributing this to an enclosing alt or
	// interleave statement.
	KILLEDA Opcode = 0x1263

	// Evaluate a <= b, pushing the boolean result.
	LE Opcode = 0x0533

	// Create a length restriction with length len and apply to obj,
	// leaving the result on the stack. len may be a range
	// constructed with the range operation.
	LENGTH Opcode = 0x0643

	// Takes the length of the string-type object str and pushes it
	// onto the stack.
	LENGTHOF Opcode = 0x19b3

	// Loads a local object indexed by x, where x is an unsigned
	// integer value in the range 0 to 32767.
	LOAD Opcode = 0x0053

	// Log the items in collection coll or log the single object obj.
	LOG Opcode = 0x1013

	// Evaluate a < b, pushing the boolean result.
	LT Opcode = 0x0543

	// Map port p1 to port p2.
	MAP Opcode = 0x10c3

	// Construct a map type object with key typek and value typev
	// and push on to the stack.
	MAPT Opcode = 0x0fc3

	// Push a mark object onto the stack.
	MARK Opcode = 0x00c3

	// Perform template matching of expression expr against template
	// tmpl returning a boolean result on the stack.
	MATCH Opcode = 0x1023

	// Evaluate a mod b, pushing the result on the stack. The TTCN-3
	// definition of mod applies.
	//
	// The types of a and b must be compatible. The returned object
	// has the base type of the input parameters and is constant.
	MOD Opcode = 0x0463

	// Define a module object and attach it to the source object
	// owning the current block. Parameters are a block dblk of
	// sub-definitions and the group name.
	MODULE Opcode = 0x08e3

	// Define a module object with attributes.
	MODULEW Opcode = 0x08f3

	// Move b to a
	MOVE Opcode = 0x05e3

	// Create a module parameter definition from its type and a name.
	MPAR Opcode = 0x0a03

	// Create a module parameter definition from a block vblk
	// containing the statements of its default value, its type and a
	// name.
	MPARD Opcode = 0x0a13

	// Fetch a reference to the current MTC and push it on the stack.
	MTC Opcode = 0x0213

	// Evaluate a * b, pushing the result on the stack.
	//
	// The types of a and b must be compatible. The returned object
	// has the base type of the input parameters and is constant.
	MUL Opcode = 0x0443

	// Push an object name literal onto the stack, coded as an ASCII
	// string. This is a variable-length instruction with the details
	// of the name following the instruction itself: first, a length
	// field, and then the bytes of the string.
	//
	// The length field is encoded with the same byte order as has
	// been selected for instructions. The string itself is always
	// encoded with the first byte of the string at the lowest file
	// offset – the natural ordering for strings.
	//
	// Padding shall be placed at the end of the string bytes to
	// restore the correct alignment for following instructions.
	NAME Opcode = 0x0183

	// Push a signed integer literal onto the stack. This is a
	// variable-length instruction with the value of the literal
	// integer following the instruction itself as a native long.
	//
	// The literal integer value is encoded at the same width and
	// byte ordering as is currently selected for instructions: is
	// must be swapped when swapping is enabled.
	//
	// If the currently selected instruction width is too small for
	// the encoding of a particular value then the istr literal
	// operation shall be used instead.
	NATLONG Opcode = 0x0143

	// Evaluate a != b, pushing the boolean result.
	NE Opcode = 0x0553

	// Evaluate -a (unary - operator) pushing the result.
	NEG Opcode = 0x0423

	// Encoding of 9 nibbles, showing nibble endian-ness:
	// ‘BADC0FFEE’H
	//
	// Note: 9th nibble in the upper half of most significant byte
	//
	// 0000 0123
	// 0000 0009
	// BADC 0FFE
	// E000 0000
	NIBBLES Opcode = 0x0123

	// Push a special literal on the stack corresponding to the none
	// term of verdicttype.
	NONE Opcode = 0x02a3

	// No operation.
	//
	// nop shall normally be combined with eswap. Refer to the eswap
	// operation.
	NOP Opcode = 0x0003

	// With boolean input, perform the logical not operation and
	// return the boolean result.
	//
	// With bitstring, hexstring or octetstring input, perform the
	// bitwise not operation and return the result. The result type
	// will be of the same base type as the inputs.
	NOT Opcode = 0x0493

	NOW Opcode = 0x1343

	NULL Opcode = 0x0203

	// Convert octetstring oct into a bitstring and push it onto the
	// stack.
	OCT2BIT Opcode = 0x1943

	OCT2CHR Opcode = 0x1973

	// Convert octetstring oct into a hexstring and push it onto the
	// stack.
	OCT2HEX Opcode = 0x1953

	// Convert octetstring oct into an integer and push it onto the
	// stack.
	OCT2INT Opcode = 0x1933

	// Convert octetstring oct into a charstring and push it onto the
	// stack.
	OCT2STR Opcode = 0x1963

	// Push an octetstring literal onto the stack. This is a
	// variable-length instruction with the details of the literal
	// octetstring following the instruction itself: first, a length
	// field, and then the bytes of the octetstring.
	//
	// The length field is encoded with the same byte order as has
	// been selected for instructions. The length contains the number
	// of octets.
	//
	// The string itself is always encoded with the first octet of
	// the string at the lowest file offset – the natural ordering
	// for strings.
	//
	// Padding shall be placed at the end of the string bytes to
	// restore the correct alignment for following instructions.
	OCTETS Opcode = 0x0133

	// Push the built-in octetstring type object.
	OCTETSTRING Opcode = 0x0e73

	// Push a special omit literal onto the stack.
	OMIT Opcode = 0x0253

	// With a boolean first argument perform the logical or operation
	// and return the boolean result. The second argument shall be
	// either another boolean or a block. If the first argument is
	// true then the second argument shall not be evaluated.
	//
	// With bitstring, hexstring or octetstring inputs, perform the
	// bitwise or operation and return the result. The result type
	// will be of the same base type as the inputs.
	OR Opcode = 0x04a3

	// Bind a type and name into an output value parameter object and
	// then attach this to the owning function (altstep, testcase)
	// object.
	OUT Opcode = 0x0763

	// Push a special literal on the stack corresponding to the pass
	// term of verdicttype.
	PASS Opcode = 0x02b3

	// Make string str into a pattern template literal and push this
	// on the stack.
	//
	// In addition to the obvious use with charstring and universal
	// charstring types, pattern shall be used for bitstring,
	// hexstring and octetstring literals when they contain
	// pattern-matching characters.
	PATTERN Opcode = 0x0653

	// Modifies a type object to allow it to have the special omit
	// value.
	PERMITO Opcode = 0x0783

	// Modifies a type object to allow it to have ifpresent values.
	PERMITP Opcode = 0x07a3

	// Modifies a type object to allow it to have template values.
	PERMITT Opcode = 0x0793

	// Make a permutation template literal from the input value list
	// vlist. Push the resulting object on the stack.
	PERMUTATION Opcode = 0x0663

	// Construct a message port type object push onto the stack.
	// Block iblk shall contain a list of types allowed in through
	// the port and block oblk shall contain a list of types allowed
	// out through the port. The same type may appear in both lists.
	//
	// Refer to the TTCN-3 specification for the precise meaning of
	// the terms in and out under various circumstances.
	PORTM Opcode = 0x0f43

	// Create message port type
	PORTMA Opcode = 0x0f63

	// Construct a range template literal from bounds lower and
	// upper. Push the resulting object on the stack.
	RANGE Opcode = 0x0673

	// Read the remaining duration of timer tmr and push the float
	// result onto the stack.
	READ Opcode = 0x1303

	// Create a receive condition on port port. Block mblk shall
	// contain code to perform the matching of input. When the
	// condition is true (matched) then the enclosing alt will
	// execute block ablk to perform variable assignments.
	RECEIVE Opcode = 0x1443

	// Receive from any port
	RECEIVE1 Opcode = 0x1463

	// Create a checked receive condition on port port. Block mblk
	// shall contain code to perform the matching of input. When the
	// condition is true (matched) then the enclosing alt will
	// execute block ablk to perform variable assignments.
	RECEIVEC Opcode = 0x1453

	RECEIVEC1 Opcode = 0x1473

	// Construct a record object from field definitions in block fblk
	// and push on to the stack.
	RECORD Opcode = 0x0f83

	// Construct a record-of object with element of type type and
	// push on to the stack.
	RECORDOF Opcode = 0x0fa3

	REF_BIT2HEX Opcode = 0x1dc3

	REF_BIT2INT Opcode = 0x1db3

	REF_BIT2OCT Opcode = 0x1dd3

	REF_BIT2STR Opcode = 0x1de3

	REF_CHAR2INT Opcode = 0x1d83

	REF_CHAR2OCT Opcode = 0x1d93

	REF_DECVALUE Opcode = 0x1f83

	REF_ENCVALUE Opcode = 0x1f73

	REF_ENUM2INT Opcode = 0x1f53

	REF_FLOAT2INT Opcode = 0x1d73

	REF_HEX2BIT Opcode = 0x1e03

	REF_HEX2INT Opcode = 0x1df3

	REF_HEX2OCT Opcode = 0x1e13

	REF_HEX2STR Opcode = 0x1e23

	REF_INT2BIT Opcode = 0x1d23

	REF_INT2CHAR Opcode = 0x1d03

	REF_INT2ENUM Opcode = 0x1fa3

	REF_INT2FLOAT Opcode = 0x1d63

	REF_INT2HEX Opcode = 0x1d33

	REF_INT2OCT Opcode = 0x1d43

	REF_INT2STR Opcode = 0x1d53

	REF_ISBOUND Opcode = 0x1fd3

	REF_ISPRESENT Opcode = 0x1ee3

	REF_ISVALUE Opcode = 0x1f63

	REF_OCT2BIT Opcode = 0x1e43

	REF_OCT2CHR Opcode = 0x1e73

	REF_OCT2HEX Opcode = 0x1e53

	REF_OCT2INT Opcode = 0x1e33

	REF_OCT2STR Opcode = 0x1e63

	REF_REGEXP Opcode = 0x1f03

	REF_STR2FLOAT Opcode = 0x1ea3

	REF_STR2HEX Opcode = 0x1fc3

	REF_STR2INT Opcode = 0x1e83

	REF_STR2OCT Opcode = 0x1e93

	REF_TESTCASENAME Opcode = 0x1f93

	REF_VAL2STR Opcode = 0x1ed3

	// Perform a regular expression match of str against expr.
	// Returns the gno-th matching bracketed sub-expression or an
	// empty string if no match.
	REGEXP Opcode = 0x1a03

	// Evaluate a rem b, pushing the result on the stack. The TTCN-3
	// definition of rem applies.
	//
	// The types of a and b must be compatible. The returned object
	// has the base type of the input parameters and is constant.
	REM Opcode = 0x0473

	// Cause the immediate repeat of the evaluation of the current
	// enclosing alt.
	REPEAT Opcode = 0x03b3

	// Replace the substring of str, from index idx, for length len,
	// with the string rep and return the resulting string.
	REPLACE Opcode = 0x1a23

	// Causes immediate exit from the current function, altstep,
	// testcase or control.
	RETURN Opcode = 0x0323

	// Compute a random float in the range 0 and 1 exclusive, and
	// return the result.
	RND Opcode = 0x1a33

	// Rotate string str left by num items, and return the result.
	ROL Opcode = 0x04e3

	// Rotate string str right by num items, and return the result.
	ROR Opcode = 0x04f3

	// When called with a component reference comp, evaluate the
	// running state of the component and push the boolean result
	// onto the stack.
	//
	// When called with a timer reference tmr, evaluate the running
	// state of the timer and push the boolean result onto the stack.
	RUNNING Opcode = 0x1203

	// Evaluate the state of parallel test components to determine if
	// any are in the running state. Push the boolean result on the
	// stack.
	RUNNING1C Opcode = 0x1213

	// Evaluate the state of timers on the current component to
	// determine if any are in the running state. Push the boolean
	// result on the stack.
	RUNNING1T Opcode = 0x1313

	// Evaluate the state of parallel test components to determine if
	// all are in the running state. Push the boolean result on the
	// stack.
	RUNNINGAC Opcode = 0x1223

	// Switch from instruction execution to scanning until a matching
	// block is seen.
	SCAN Opcode = 0x00d3

	// Fetch a reference to the current component and push it on the
	// stack.
	SELF Opcode = 0x0223

	// Send message msg on port port with no explicit addressing.
	SEND Opcode = 0x1403

	// Send message msg on port port to single destination dest
	// (unicast.)
	SEND1 Opcode = 0x1413

	// Send message msg on port port to all associated destinations
	// (broadcast.)
	SENDA Opcode = 0x1433

	// Fetch the sender (from) address of the current communication
	// operation.
	SENDER Opcode = 0x17e3

	// Send message msg on port port to all destinations in block
	// dblk (multicast.)
	SENDN Opcode = 0x1423

	// Construct a set object from field definitions in block fblk
	// and push on to the stack.
	SET Opcode = 0x0f93

	// Construct a set-of object with element of type type and push
	// on to the stack.
	SETOF Opcode = 0x0fb3

	// Set the local verdict of the current component from parameter
	// lver. Use within the control part is a runtime error.
	SETVERDICT Opcode = 0x1053

	// Shift string str left by num items, and return the result.
	SHL Opcode = 0x04c3

	// Shift string str right by num items, and return the result.
	SHR Opcode = 0x04d3

	// Pushes the number of elements in obj onto the stack as an
	// integer value.
	SIZEOF Opcode = 0x19c3

	// Push a special literal onto the stack, corresponding to the
	// TTCN-3 ‘-‘ and meaning ‘skip this item.’
	//
	// As an optimisation, skip may be used instead of an empty
	// block, saving one operation and avoid invocation of the block
	// scanning mechanism.
	SKIP Opcode = 0x0243

	// Silent match
	SMATCH Opcode = 0x00f3

	// Define a source file object with file name name and module
	// definitions contained in block mblk.
	SOURCE Opcode = 0x08d3

	// Special place
	SPECPLC Opcode = 0x0d43

	// When called with a port reference port, start activity on the
	// port.
	//
	// When called with a timer reference tmr, start the timer
	// running (or restart.)
	START Opcode = 0x1283

	// Start activity on all ports.
	STARTAP Opcode = 0x12b3

	// Start behaviour on parallel test component comp. Block blk
	// contains the instructions to execute in the context of the
	// newly started component – the behaviour. This shall take the
	// form of any parameters followed by a function call.
	STARTC Opcode = 0x1293

	// Start timer tmr, with explicit duration dur.
	STARTD Opcode = 0x12a3

	// Create an alternative for an enclosing alt operation,
	// associating some condition with statements to perform should
	// the condition be chosen by the alt operation. Block cblk
	// contains code to execute to evaluate the condition of the
	// alternative. Block sblk contains code to execute should be
	// condition be chosen.
	STEP Opcode = 0x03e3

	// When called with a component reference comp, stop behaviour on
	// the component.
	//
	// When called with a port reference port, stop activity on the
	// port.
	//
	// When called with a timer reference tmr, stop the timer.
	STOP Opcode = 0x12c3

	// Stop all parallel test components. Permitted only from the
	// master test component.
	STOPAC Opcode = 0x12d3

	// Stop all ports.
	STOPAP Opcode = 0x12e3

	// Stop all timers on the current component.
	STOPAT Opcode = 0x12f3

	// From within the behaviour of a component, causes immediate
	// termination of the behaviour of that component.
	//
	// From within the behaviour of a control part, causes immediate
	// termination of the execution of that control part.
	STOPI Opcode = 0x0333

	// Stores a local object indexed by x, where x in an unsigned
	// integer value in the range 0 to 32767.
	STORE Opcode = 0x0063

	// Convert charstring char into a float, and push it onto the
	// stack.
	STR2FLOAT Opcode = 0x19a3

	STR2HEX Opcode = 0x1ac3

	// Convert charstring char into an integer, and push it onto the
	// stack.
	STR2INT Opcode = 0x1983

	// Convert charstring char into an octetstring, and push it onto
	// the stack.
	STR2OCT Opcode = 0x1993

	// Evaluate a – b, pushing the result on the stack.
	//
	// The types of a and b must be compatible. The returned object
	// has the base type of the input parameters and is constant.
	SUB Opcode = 0x0433

	// Make a subset template literal from the input value list
	// vlist. Push the resulting object on the stack.
	SUBSET Opcode = 0x0683

	// Return the substring of str, from index idx, for length len.
	SUBSTR Opcode = 0x1a13

	// Create a subtype from type applying constraint cons, pushing
	// the resulting type object on the stack. Constraint cons may be
	// a single object or a collection of objects.
	SUBTYPE Opcode = 0x0ef3

	// Make a superset template literal from the input value list
	// vlist. Push the resulting object on the stack.
	SUPERSET Opcode = 0x0693

	// Fetch a reference to the current test system interface
	// component and push it on the stack.
	SYSTEM Opcode = 0x0233

	// Stop testcase.
	TCSTOP Opcode = 0x11e3

	// Define a template object from return type, a block pblk
	// containing its parameters, bblk containing its behaviour and a
	// name, and then attach it to the module object owning the
	// current block.
	TEMPLATE Opcode = 0x0a43

	// Bind an integer value and name into an enumeration term
	// definition and then attach this to the owning enumeration
	// object.
	TERM Opcode = 0x0713

	// Define a testcase object from a runs-on component type rcomp,
	// a block pblk containing its parameters, bblk containing its
	// behaviour and a name, and then attach it to the module object
	// owning the current block.
	TESTCASE Opcode = 0x0a83

	// Retrieve the current testcase name and push onto the stack.
	// Returns an empty string if called outside any executing
	// testcase.
	TESTCASENAME Opcode = 0x1a93

	// Define a testcase object from a system component type scomp, a
	// runs-on component type rcomp, a block pblk containing its
	// parameters, bblk containing its behaviour and a name, and then
	// attach it to the module object owning the current block.
	TESTCASES Opcode = 0x0a93

	// Define a testcase object from a system component type scomp, a
	// runs-on component type rcomp, a block pblk containing its
	// parameters, bblk containing its behaviour and a name, and then
	// attach it to the module object owning the current block.
	// Attach attributes from block ablk.
	TESTCASESW Opcode = 0x0ab3

	// Define a testcase object from a runs-on component type rcomp,
	// a block pblk containing its parameters, bblk containing its
	// behaviour and a name, and then attach it to the module object
	// owning the current block. Attach attributes from block ablk.
	TESTCASEW Opcode = 0x0aa3

	// Create a timeout alternative bound to timer tmr and attach
	// this to the enclosing alt operation.
	TIMEOUT Opcode = 0x1323

	// Create a timeout alternative bound to the expiry of any
	// current timer and attach this to the enclosing alt operation.
	TIMEOUT1 Opcode = 0x1333

	// Push the built-in timer type object.
	TIMER Opcode = 0x0ed3

	TIMESTAMP Opcode = 0x17f3

	// Implements the TTCN-3 .to operation applied to mapv of
	// type: `type map from A to B MapT`. A setofToType is provided
	// for creation of the return value.
	// Return value is of type `set of B` containing all values
	// from the map.
	TO Opcode = 0x06d3

	// Create a trigger condition on port port. Block mblk shall
	// contain code to perform the matching of input. When the
	// trigger condition is true (matched) then the enclosing alt
	// will execute block ablk to perform variable assignment.
	TRIGGER Opcode = 0x1483

	TRIGGER1 Opcode = 0x1493

	// Push a special true literal onto the stack.
	TRUE Opcode = 0x0293

	// Associate a type object and name into a type definition object
	// and then attach this to the owning module or group definition.
	TYPE Opcode = 0x0a63

	// Associate a type object and name into a type definition object
	// and then attach this to the owning module or group definition.
	// Attributes from block ablk are attached.
	TYPEW Opcode = 0x0a73

	// Construct a union object from field definitions in block fblk
	// and push on to the stack.
	UNION Opcode = 0x0ff3

	// Break the mapping between port p1 and port p2.
	UNMAP Opcode = 0x10d3

	// Break all mappings from component comp.
	UNMAPA Opcode = 0x10e3

	// Break all mappings on all components.
	UNMAPAA Opcode = 0x10f3

	// remove key from mapval.
	UNMAPFROMTO Opcode = 0x0fd3

	// Push a string literal onto the stack. This is a
	// variable-length instruction with the details of the literal
	// string following the instruction itself: first, a length
	// field, then the bytes of the string, encoded UTF-8.
	//
	// The length field is encoded with the same byte order as has
	// been selected for instructions. The string itself is always
	// encoded with the first byte of the string at the lowest file
	// offset – the natural ordering for strings.
	//
	// Padding shall be placed at the end of the string bytes to
	// restore the correct alignment for following instructions.
	UTF8 Opcode = 0x0103

	// Return a printable representation of val.
	VAL2STR Opcode = 0x1ae3

	// Fetch the value of the current communication operation.
	//
	// For receive and trigger operations this is the current
	// message.
	//
	// For getreply this is the return value of the current
	// procedure.
	//
	// For catch this is the exception of the current procedure.
	VALUE Opcode = 0x17c3

	// Check template tmpl. If it has a single value then return this
	// on the stack otherwise raise a runtime error.
	VALUEOF Opcode = 0x1033

	// Create a variable with the given type and name. Bind this
	// variable to the current function (control, altstep, testcase.)
	VAR Opcode = 0x0703

	// Create a variable with eager template evaluation.
	VARDUP Opcode = 0x06f3

	// Attach the variant attribute val to the object owning the
	// current block.
	VARIANT Opcode = 0x0cc3

	// Attach the overriding variant attribute val to the object
	// owning the current block.
	VARIANTO Opcode = 0x0ce3

	// Push the built-in verdicttype type object.
	VERDICTTYPE Opcode = 0x0e83

	// Specify the version number of t3xf to which this file
	// conforms. Version numbers start from one.
	VERSION Opcode = 0x0033

	// Build a value list from a marked listed of objects,
	// potentially empty. The objects and the mark are removed from
	// the stack and replaced with a value list object.
	VLIST Opcode = 0x0073

	// Wait for float seconds.
	WAIT Opcode = 0x1353

	// Implements the TTCN-3 while statement using two block
	// arguments.
	//
	// Block cond is evaluated to test the loop condition. If the
	// block yields a true value then block body is executed before
	// looping to evaluate the condition again.
	//
	// Execution terminates when the loop condition returns a false
	// value.
	WHILE Opcode = 0x0353

	// With boolean inputs, perform the logical exclusive or
	// operation and return the boolean result.
	//
	// With bitstring, hexstring or octetstring inputs perform the
	// bitwise exclusive or operation and return the result. The
	// result type will be of the same base type as the inputs.
	XOR Opcode = 0x04b3
)

var opcodeStrings = map[Opcode]string{
	REF:        "ref",
	LINE:       "line",
	GOTO:       "goto",
	FROZEN_REF: "frozen_ref",

	ACTION:           "action",
	ACTIVATE:         "activate",
	ADD:              "add",
	ADDRESS:          "address",
	ALIVE:            "alive",
	ALIVE1:           "alive1",
	ALIVEA:           "alivea",
	ALLFROM:          "allfrom",
	ALLFROMP:         "allfromp",
	ALT:              "alt",
	ALTND:            "altnd",
	ALTSTEP:          "altstep",
	ALTSTEPB:         "altstepb",
	ALTSTEPBW:        "altstepbw",
	ALTSTEPW:         "altstepw",
	AND:              "and",
	ANY:              "any",
	ANYN:             "anyn",
	APPLY:            "apply",
	ARRAY:            "array",
	ASSIGN:           "assign",
	ASSIGND:          "assignd",
	AT_DEFAULT:       "at_default",
	BIT2HEX:          "bit2hex",
	BIT2INT:          "bit2int",
	BIT2OCT:          "bit2oct",
	BIT2STR:          "bit2str",
	BITS:             "bits",
	BITSTRING:        "bitstring",
	BLOCK:            "block",
	BOOLEAN:          "boolean",
	BREAK:            "break",
	CAT:              "cat",
	CHAR2INT:         "char2int",
	CHAR2OCT:         "char2oct",
	CHARSTRING:       "charstring",
	CHARSTRINGU:      "charstringu",
	CHECK:            "check",
	CHECK1:           "check1",
	CHECKSTATE:       "checkstate",
	CHECKSTATEAL:     "checkstateal",
	CHECKSTATEAN:     "checkstatean",
	CLEAR:            "clear",
	CLEARA:           "cleara",
	CLONE:            "clone",
	CLOSURE:          "closure",
	CLOSURETYPE:      "closuretype",
	COLLECT:          "collect",
	COMPLEMENT:       "complement",
	COMPONENT:        "component",
	COMPONENTX:       "componentx",
	CONNECT:          "connect",
	CONST:            "const",
	CONSTW:           "constw",
	CONTINUE:         "continue",
	CONTROL:          "control",
	CREATE:           "create",
	CREATEA:          "createa",
	CREATEAN:         "createan",
	CREATEN:          "createn",
	DEACTIVATE:       "deactivate",
	DEACTIVATEA:      "deactivatea",
	DECMATCH:         "decmatch",
	DECVALUE:         "decvalue",
	DEF:              "def",
	DEFAULT:          "default",
	DISCONNECT:       "disconnect",
	DISCONNECTA:      "disconnecta",
	DISCONNECTAA:     "disconnectaa",
	DIV:              "div",
	DONE:             "done",
	DONE1:            "done1",
	DONEA:            "donea",
	DOWHILE:          "dowhile",
	DROP:             "drop",
	ELSE:             "else",
	ENCODE:           "encode",
	ENCODEO:          "encodeo",
	ENCVALUE:         "encvalue",
	ENUM2INT:         "enum2int",
	ENUMERATED:       "enumerated",
	EQ:               "eq",
	ERROR:            "error",
	EXEC:             "exec",
	EXECUTE:          "execute",
	EXECUTED:         "executed",
	EXECUTEL:         "executel",
	EXECUTELD:        "executeld",
	EXTENSION:        "extension",
	EXTENSIONO:       "extensiono",
	FAIL:             "fail",
	FALSE:            "false",
	FIELD:            "field",
	FIELDO:           "fieldo",
	FLOAT:            "float",
	FLOAT2INT:        "float2int",
	FOR:              "for",
	FROM:             "from",
	FSTR:             "fstr",
	FUNCTION:         "function",
	FUNCTIONB:        "functionb",
	FUNCTIONV:        "functionv",
	FUNCTIONVB:       "functionvb",
	FUNCTIONX:        "functionx",
	FUNCTIONXV:       "functionxv",
	FUNCTIONXVW:      "functionxvw",
	FUNCTIONXW:       "functionxw",
	GE:               "ge",
	GET:              "get",
	GETVERDICT:       "getverdict",
	GT:               "gt",
	HALT:             "halt",
	HALTA:            "halta",
	HEX2BIT:          "hex2bit",
	HEX2INT:          "hex2int",
	HEX2OCT:          "hex2oct",
	HEX2STR:          "hex2str",
	HEXSTRING:        "hexstring",
	IDEF:             "idef",
	IEEE754DP:        "ieee754dp",
	IF:               "if",
	IFELSE:           "ifelse",
	IFIELD:           "ifield",
	IFPRESENT:        "ifpresent",
	IGET:             "iget",
	IN:               "in",
	INCONC:           "inconc",
	INFINITYN:        "infinityn",
	INFINITYP:        "infinityp",
	INOUT:            "inout",
	INT2BIT:          "int2bit",
	INT2CHAR:         "int2char",
	INT2ENUM:         "int2enum",
	INT2FLOAT:        "int2float",
	INT2HEX:          "int2hex",
	INT2OCT:          "int2oct",
	INT2STR:          "int2str",
	INTEGER:          "integer",
	INTERLEAVE:       "interleave",
	ISBOUND:          "isbound",
	ISCHOSEN:         "ischosen",
	ISPRESENT:        "ispresent",
	ISTR:             "istr",
	ISVALUE:          "isvalue",
	KILL:             "kill",
	KILLA:            "killa",
	KILLED:           "killed",
	KILLED1:          "killed1",
	KILLEDA:          "killeda",
	LE:               "le",
	LENGTH:           "length",
	LENGTHOF:         "lengthof",
	LOAD:             "load",
	LOG:              "log",
	LT:               "lt",
	MAP:              "map",
	MAPT:             "mapt",
	MARK:             "mark",
	MATCH:            "match",
	MOD:              "mod",
	MODULE:           "module",
	MODULEW:          "modulew",
	MOVE:             "move",
	MPAR:             "mpar",
	MPARD:            "mpard",
	MTC:              "mtc",
	MUL:              "mul",
	NAME:             "name",
	NATLONG:          "natlong",
	NE:               "ne",
	NEG:              "neg",
	NIBBLES:          "nibbles",
	NONE:             "none",
	NOP:              "nop",
	NOT:              "not",
	NOW:              "now",
	NULL:             "null",
	OCT2BIT:          "oct2bit",
	OCT2CHR:          "oct2chr",
	OCT2HEX:          "oct2hex",
	OCT2INT:          "oct2int",
	OCT2STR:          "oct2str",
	OCTETS:           "octets",
	OCTETSTRING:      "octetstring",
	OMIT:             "omit",
	OR:               "or",
	OUT:              "out",
	PASS:             "pass",
	PATTERN:          "pattern",
	PERMITO:          "permito",
	PERMITP:          "permitp",
	PERMITT:          "permitt",
	PERMUTATION:      "permutation",
	PORTM:            "portm",
	PORTMA:           "portma",
	RANGE:            "range",
	READ:             "read",
	RECEIVE:          "receive",
	RECEIVE1:         "receive1",
	RECEIVEC:         "receivec",
	RECEIVEC1:        "receivec1",
	RECORD:           "record",
	RECORDOF:         "recordof",
	REF_BIT2HEX:      "ref_bit2hex",
	REF_BIT2INT:      "ref_bit2int",
	REF_BIT2OCT:      "ref_bit2oct",
	REF_BIT2STR:      "ref_bit2str",
	REF_CHAR2INT:     "ref_char2int",
	REF_CHAR2OCT:     "ref_char2oct",
	REF_DECVALUE:     "ref_decvalue",
	REF_ENCVALUE:     "ref_encvalue",
	REF_ENUM2INT:     "ref_enum2int",
	REF_FLOAT2INT:    "ref_float2int",
	REF_HEX2BIT:      "ref_hex2bit",
	REF_HEX2INT:      "ref_hex2int",
	REF_HEX2OCT:      "ref_hex2oct",
	REF_HEX2STR:      "ref_hex2str",
	REF_INT2BIT:      "ref_int2bit",
	REF_INT2CHAR:     "ref_int2char",
	REF_INT2ENUM:     "ref_int2enum",
	REF_INT2FLOAT:    "ref_int2float",
	REF_INT2HEX:      "ref_int2hex",
	REF_INT2OCT:      "ref_int2oct",
	REF_INT2STR:      "ref_int2str",
	REF_ISBOUND:      "ref_isbound",
	REF_ISPRESENT:    "ref_ispresent",
	REF_ISVALUE:      "ref_isvalue",
	REF_OCT2BIT:      "ref_oct2bit",
	REF_OCT2CHR:      "ref_oct2chr",
	REF_OCT2HEX:      "ref_oct2hex",
	REF_OCT2INT:      "ref_oct2int",
	REF_OCT2STR:      "ref_oct2str",
	REF_REGEXP:       "ref_regexp",
	REF_STR2FLOAT:    "ref_str2float",
	REF_STR2HEX:      "ref_str2hex",
	REF_STR2INT:      "ref_str2int",
	REF_STR2OCT:      "ref_str2oct",
	REF_TESTCASENAME: "ref_testcasename",
	REF_VAL2STR:      "ref_val2str",
	REGEXP:           "regexp",
	REM:              "rem",
	REPEAT:           "repeat",
	REPLACE:          "replace",
	RETURN:           "return",
	RND:              "rnd",
	ROL:              "rol",
	ROR:              "ror",
	RUNNING:          "running",
	RUNNING1C:        "running1c",
	RUNNING1T:        "running1t",
	RUNNINGAC:        "runningac",
	SCAN:             "scan",
	SELF:             "self",
	SEND:             "send",
	SEND1:            "send1",
	SENDA:            "senda",
	SENDER:           "sender",
	SENDN:            "sendn",
	SET:              "set",
	SETOF:            "setof",
	SETVERDICT:       "setverdict",
	SHL:              "shl",
	SHR:              "shr",
	SIZEOF:           "sizeof",
	SKIP:             "skip",
	SMATCH:           "smatch",
	SOURCE:           "source",
	SPECPLC:          "specplc",
	START:            "start",
	STARTAP:          "startap",
	STARTC:           "startc",
	STARTD:           "startd",
	STEP:             "step",
	STOP:             "stop",
	STOPAC:           "stopac",
	STOPAP:           "stopap",
	STOPAT:           "stopat",
	STOPI:            "stopi",
	STORE:            "store",
	STR2FLOAT:        "str2float",
	STR2HEX:          "str2hex",
	STR2INT:          "str2int",
	STR2OCT:          "str2oct",
	SUB:              "sub",
	SUBSET:           "subset",
	SUBSTR:           "substr",
	SUBTYPE:          "subtype",
	SUPERSET:         "superset",
	SYSTEM:           "system",
	TCSTOP:           "tcstop",
	TEMPLATE:         "template",
	TERM:             "term",
	TESTCASE:         "testcase",
	TESTCASENAME:     "testcasename",
	TESTCASES:        "testcases",
	TESTCASESW:       "testcasesw",
	TESTCASEW:        "testcasew",
	TIMEOUT:          "timeout",
	TIMEOUT1:         "timeout1",
	TIMER:            "timer",
	TIMESTAMP:        "timestamp",
	TO:               "to",
	TRIGGER:          "trigger",
	TRIGGER1:         "trigger1",
	TRUE:             "true",
	TYPE:             "type",
	TYPEW:            "typew",
	UNION:            "union",
	UNMAP:            "unmap",
	UNMAPA:           "unmapa",
	UNMAPAA:          "unmapaa",
	UNMAPFROMTO:      "unmapfromto",
	UTF8:             "utf8",
	VAL2STR:          "val2str",
	VALUE:            "value",
	VALUEOF:          "valueof",
	VAR:              "var",
	VARDUP:           "vardup",
	VARIANT:          "variant",
	VARIANTO:         "varianto",
	VERDICTTYPE:      "verdicttype",
	VERSION:          "version",
	VLIST:            "vlist",
	WAIT:             "wait",
	WHILE:            "while",
	XOR:              "xor",
}

var opcodeNames = map[string]Opcode{
	"ref":        REF,
	"line":       LINE,
	"goto":       GOTO,
	"frozen_ref": FROZEN_REF,

	"action":           ACTION,
	"activate":         ACTIVATE,
	"add":              ADD,
	"address":          ADDRESS,
	"alive":            ALIVE,
	"alive1":           ALIVE1,
	"alivea":           ALIVEA,
	"allfrom":          ALLFROM,
	"allfromp":         ALLFROMP,
	"alt":              ALT,
	"altnd":            ALTND,
	"altstep":          ALTSTEP,
	"altstepb":         ALTSTEPB,
	"altstepbw":        ALTSTEPBW,
	"altstepw":         ALTSTEPW,
	"and":              AND,
	"any":              ANY,
	"anyn":             ANYN,
	"apply":            APPLY,
	"array":            ARRAY,
	"assign":           ASSIGN,
	"assignd":          ASSIGND,
	"at_default":       AT_DEFAULT,
	"bit2hex":          BIT2HEX,
	"bit2int":          BIT2INT,
	"bit2oct":          BIT2OCT,
	"bit2str":          BIT2STR,
	"bits":             BITS,
	"bitstring":        BITSTRING,
	"block":            BLOCK,
	"boolean":          BOOLEAN,
	"break":            BREAK,
	"cat":              CAT,
	"char2int":         CHAR2INT,
	"char2oct":         CHAR2OCT,
	"charstring":       CHARSTRING,
	"charstringu":      CHARSTRINGU,
	"check":            CHECK,
	"check1":           CHECK1,
	"checkstate":       CHECKSTATE,
	"checkstateal":     CHECKSTATEAL,
	"checkstatean":     CHECKSTATEAN,
	"clear":            CLEAR,
	"cleara":           CLEARA,
	"clone":            CLONE,
	"closure":          CLOSURE,
	"closuretype":      CLOSURETYPE,
	"collect":          COLLECT,
	"complement":       COMPLEMENT,
	"component":        COMPONENT,
	"componentx":       COMPONENTX,
	"connect":          CONNECT,
	"const":            CONST,
	"constw":           CONSTW,
	"continue":         CONTINUE,
	"control":          CONTROL,
	"create":           CREATE,
	"createa":          CREATEA,
	"createan":         CREATEAN,
	"createn":          CREATEN,
	"deactivate":       DEACTIVATE,
	"deactivatea":      DEACTIVATEA,
	"decmatch":         DECMATCH,
	"decvalue":         DECVALUE,
	"def":              DEF,
	"default":          DEFAULT,
	"disconnect":       DISCONNECT,
	"disconnecta":      DISCONNECTA,
	"disconnectaa":     DISCONNECTAA,
	"div":              DIV,
	"done":             DONE,
	"done1":            DONE1,
	"donea":            DONEA,
	"dowhile":          DOWHILE,
	"drop":             DROP,
	"else":             ELSE,
	"encode":           ENCODE,
	"encodeo":          ENCODEO,
	"encvalue":         ENCVALUE,
	"enum2int":         ENUM2INT,
	"enumerated":       ENUMERATED,
	"eq":               EQ,
	"error":            ERROR,
	"exec":             EXEC,
	"execute":          EXECUTE,
	"executed":         EXECUTED,
	"executel":         EXECUTEL,
	"executeld":        EXECUTELD,
	"extension":        EXTENSION,
	"extensiono":       EXTENSIONO,
	"fail":             FAIL,
	"false":            FALSE,
	"field":            FIELD,
	"fieldo":           FIELDO,
	"float":            FLOAT,
	"float2int":        FLOAT2INT,
	"for":              FOR,
	"from":             FROM,
	"fstr":             FSTR,
	"function":         FUNCTION,
	"functionb":        FUNCTIONB,
	"functionv":        FUNCTIONV,
	"functionvb":       FUNCTIONVB,
	"functionx":        FUNCTIONX,
	"functionxv":       FUNCTIONXV,
	"functionxvw":      FUNCTIONXVW,
	"functionxw":       FUNCTIONXW,
	"ge":               GE,
	"get":              GET,
	"getverdict":       GETVERDICT,
	"gt":               GT,
	"halt":             HALT,
	"halta":            HALTA,
	"hex2bit":          HEX2BIT,
	"hex2int":          HEX2INT,
	"hex2oct":          HEX2OCT,
	"hex2str":          HEX2STR,
	"hexstring":        HEXSTRING,
	"idef":             IDEF,
	"ieee754dp":        IEEE754DP,
	"if":               IF,
	"ifelse":           IFELSE,
	"ifield":           IFIELD,
	"ifpresent":        IFPRESENT,
	"iget":             IGET,
	"in":               IN,
	"inconc":           INCONC,
	"infinityn":        INFINITYN,
	"infinityp":        INFINITYP,
	"inout":            INOUT,
	"int2bit":          INT2BIT,
	"int2char":         INT2CHAR,
	"int2enum":         INT2ENUM,
	"int2float":        INT2FLOAT,
	"int2hex":          INT2HEX,
	"int2oct":          INT2OCT,
	"int2str":          INT2STR,
	"integer":          INTEGER,
	"interleave":       INTERLEAVE,
	"isbound":          ISBOUND,
	"ischosen":         ISCHOSEN,
	"ispresent":        ISPRESENT,
	"istr":             ISTR,
	"isvalue":          ISVALUE,
	"kill":             KILL,
	"killa":            KILLA,
	"killed":           KILLED,
	"killed1":          KILLED1,
	"killeda":          KILLEDA,
	"le":               LE,
	"length":           LENGTH,
	"lengthof":         LENGTHOF,
	"load":             LOAD,
	"log":              LOG,
	"lt":               LT,
	"map":              MAP,
	"mapt":             MAPT,
	"mark":             MARK,
	"match":            MATCH,
	"mod":              MOD,
	"module":           MODULE,
	"modulew":          MODULEW,
	"move":             MOVE,
	"mpar":             MPAR,
	"mpard":            MPARD,
	"mtc":              MTC,
	"mul":              MUL,
	"name":             NAME,
	"natlong":          NATLONG,
	"ne":               NE,
	"neg":              NEG,
	"nibbles":          NIBBLES,
	"none":             NONE,
	"nop":              NOP,
	"not":              NOT,
	"now":              NOW,
	"null":             NULL,
	"oct2bit":          OCT2BIT,
	"oct2chr":          OCT2CHR,
	"oct2hex":          OCT2HEX,
	"oct2int":          OCT2INT,
	"oct2str":          OCT2STR,
	"octets":           OCTETS,
	"octetstring":      OCTETSTRING,
	"omit":             OMIT,
	"or":               OR,
	"out":              OUT,
	"pass":             PASS,
	"pattern":          PATTERN,
	"permito":          PERMITO,
	"permitp":          PERMITP,
	"permitt":          PERMITT,
	"permutation":      PERMUTATION,
	"portm":            PORTM,
	"portma":           PORTMA,
	"range":            RANGE,
	"read":             READ,
	"receive":          RECEIVE,
	"receive1":         RECEIVE1,
	"receivec":         RECEIVEC,
	"receivec1":        RECEIVEC1,
	"record":           RECORD,
	"recordof":         RECORDOF,
	"ref_bit2hex":      REF_BIT2HEX,
	"ref_bit2int":      REF_BIT2INT,
	"ref_bit2oct":      REF_BIT2OCT,
	"ref_bit2str":      REF_BIT2STR,
	"ref_char2int":     REF_CHAR2INT,
	"ref_char2oct":     REF_CHAR2OCT,
	"ref_decvalue":     REF_DECVALUE,
	"ref_encvalue":     REF_ENCVALUE,
	"ref_enum2int":     REF_ENUM2INT,
	"ref_float2int":    REF_FLOAT2INT,
	"ref_hex2bit":      REF_HEX2BIT,
	"ref_hex2int":      REF_HEX2INT,
	"ref_hex2oct":      REF_HEX2OCT,
	"ref_hex2str":      REF_HEX2STR,
	"ref_int2bit":      REF_INT2BIT,
	"ref_int2char":     REF_INT2CHAR,
	"ref_int2enum":     REF_INT2ENUM,
	"ref_int2float":    REF_INT2FLOAT,
	"ref_int2hex":      REF_INT2HEX,
	"ref_int2oct":      REF_INT2OCT,
	"ref_int2str":      REF_INT2STR,
	"ref_isbound":      REF_ISBOUND,
	"ref_ispresent":    REF_ISPRESENT,
	"ref_isvalue":      REF_ISVALUE,
	"ref_oct2bit":      REF_OCT2BIT,
	"ref_oct2chr":      REF_OCT2CHR,
	"ref_oct2hex":      REF_OCT2HEX,
	"ref_oct2int":      REF_OCT2INT,
	"ref_oct2str":      REF_OCT2STR,
	"ref_regexp":       REF_REGEXP,
	"ref_str2float":    REF_STR2FLOAT,
	"ref_str2hex":      REF_STR2HEX,
	"ref_str2int":      REF_STR2INT,
	"ref_str2oct":      REF_STR2OCT,
	"ref_testcasename": REF_TESTCASENAME,
	"ref_val2str":      REF_VAL2STR,
	"regexp":           REGEXP,
	"rem":              REM,
	"repeat":           REPEAT,
	"replace":          REPLACE,
	"return":           RETURN,
	"rnd":              RND,
	"rol":              ROL,
	"ror":              ROR,
	"running":          RUNNING,
	"running1c":        RUNNING1C,
	"running1t":        RUNNING1T,
	"runningac":        RUNNINGAC,
	"scan":             SCAN,
	"self":             SELF,
	"send":             SEND,
	"send1":            SEND1,
	"senda":            SENDA,
	"sender":           SENDER,
	"sendn":            SENDN,
	"set":              SET,
	"setof":            SETOF,
	"setverdict":       SETVERDICT,
	"shl":              SHL,
	"shr":              SHR,
	"sizeof":           SIZEOF,
	"skip":             SKIP,
	"smatch":           SMATCH,
	"source":           SOURCE,
	"specplc":          SPECPLC,
	"start":            START,
	"startap":          STARTAP,
	"startc":           STARTC,
	"startd":           STARTD,
	"step":             STEP,
	"stop":             STOP,
	"stopac":           STOPAC,
	"stopap":           STOPAP,
	"stopat":           STOPAT,
	"stopi":            STOPI,
	"store":            STORE,
	"str2float":        STR2FLOAT,
	"str2hex":          STR2HEX,
	"str2int":          STR2INT,
	"str2oct":          STR2OCT,
	"sub":              SUB,
	"subset":           SUBSET,
	"substr":           SUBSTR,
	"subtype":          SUBTYPE,
	"superset":         SUPERSET,
	"system":           SYSTEM,
	"tcstop":           TCSTOP,
	"template":         TEMPLATE,
	"term":             TERM,
	"testcase":         TESTCASE,
	"testcasename":     TESTCASENAME,
	"testcases":        TESTCASES,
	"testcasesw":       TESTCASESW,
	"testcasew":        TESTCASEW,
	"timeout":          TIMEOUT,
	"timeout1":         TIMEOUT1,
	"timer":            TIMER,
	"timestamp":        TIMESTAMP,
	"to":               TO,
	"trigger":          TRIGGER,
	"trigger1":         TRIGGER1,
	"true":             TRUE,
	"type":             TYPE,
	"typew":            TYPEW,
	"union":            UNION,
	"unmap":            UNMAP,
	"unmapa":           UNMAPA,
	"unmapaa":          UNMAPAA,
	"unmapfromto":      UNMAPFROMTO,
	"utf8":             UTF8,
	"val2str":          VAL2STR,
	"value":            VALUE,
	"valueof":          VALUEOF,
	"var":              VAR,
	"vardup":           VARDUP,
	"variant":          VARIANT,
	"varianto":         VARIANTO,
	"verdicttype":      VERDICTTYPE,
	"version":          VERSION,
	"vlist":            VLIST,
	"wait":             WAIT,
	"while":            WHILE,
	"xor":              XOR,
}
